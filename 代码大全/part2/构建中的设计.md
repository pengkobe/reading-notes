# 构建中的设计
> 如果你认识到设计是一项明确的活动，那么你将获益匪浅。

### 设计常识
* 设计是一个险恶的问题，它可以使得大桥不经意间摧毁(tacoma narrows)
* 设计是一个无章法的过程，设计是无法确定最佳的，一般到了无时间再做了为止就好(想哭有木有/(ㄒoㄒ)/~~)
* 设计是确定取舍和调整顺序的过程,如是要运行快还是运行稳定？
* 设计受到诸多限制，准确的讲，要有限制才能完成设计
* 设计不确定性，有可能有n种方案
* 设计是一个启发性的过程，试试或许就好了，此外当前项目设计不一定适用于其它项目
* 设计是自然而然形成的，所以**不要指望一步到位**

### 设计概念

#### 管理复杂度
1. 偶然的难题与本质的难题，偶然是碰巧，本质是没有就不行，本质性困难的根源在于**复杂性**。
2. 管理复杂度非常重要，毕竟大脑容量有限，拆分为子程序或在抽象层次编程是个好方法
3. 如何面对复杂度,高代价、低效率的的设计源于没有正确认识到复杂度，当你认识到软件开发的任何技术都比不上管理复杂度重要时，
   设计上的考虑就会变得直接了当。方法有:
   - 不要让偶然性复杂度疯长
   - 控制任何人在同一时间需要处理的本质复杂度降到最少

#### 理想的设计特征
1. 最小的复杂度
2. 易于维护
3. 松散耦合
4. 可拓展性
5. 可重用性
6. 高扇入，即辅助类很好的发挥了作用
7. 低扇出，一个类内较少的或适中的使用其他类，高扇出(>7)回是的设计变得复杂
8. 可移植性
9. 精简性，考虑加进来会发生什么问题
10. 层次性，把旧的烂的的代码封闭起来。
11. 标准技术，使用易用的熟悉的方案，是的系统看起来亲切自然。(这一点持保留意见，没有绝对熟悉的方案吧？)

#### 设计的层次
![设计的层次示意图](./img/design_layer.png)  
1. 软件系统，不要直接从这层直接设计类，而应该从更高层次出发
2. 分解为子系统和包，子系统之间通信时需要考虑几点:
   - 开发人员需要了解到何种程度才能改动东西
   - 在另一系统中试图使用业务规则会发生什么
   - 加入临时系统界面会发生什么
   - 数据存储放置远程计算机会发生什么  

   子系统间不要形成闭环，形成关系有3中层次（直接调用->嵌套->继承）。  
   常见子系统有以下几种:  
   1. 用户界面
   2. 对数据库访问
   3. 对操作系统依赖性
3. 分解为类
4. 分解为子程序   
5. 子程序内部设计  

### 启发式方法
主要针对程序很难保证达到预期输出。

#### 找出现实世界的对象
主要包含几个步骤  
1. 辨识对象与属性
2. 确定对象可以进行的操作
3. 辨别对象之间的操作
4. 确定公有(public)与私有(private)
5. 定义公开接口

#### 形成一致抽象
抽象可以使你的复杂度降低

#### 封装实现细节
只能看到高层暴露的接口，而不能看到实现细节。

#### 当继承能够简化设计时就继承
继承不是目的。

#### 隐藏秘密
目的其实就是隐藏复杂度，好的类接口就像是冰山的尖一样，大部分其实是不会暴露出来的。
举例:新建ID(应该隐藏实现细节:newid(),还应该隐藏id类型:IDType)  
信息隐藏的障碍的有以下几部分:  
1. 信息过度分散
2. 循环依赖
3. 把类内部数据当作全局数据
4. 可以察觉的性能损耗  

养成问自个: **我该隐藏什么？**的习惯


#### 找出容易改变的区域
识别出容易改变的区域并进行隔离，容易变化的区域包括:

1. 业务规则
2. 对硬件的依赖
3. 输入输出
4. 非标准较语言特性，最好隐藏在单独某个类中
5. 困难的设计区域与构建区域，因为很可能需要重构
6. 状态变量  
   - 使用枚举
   - 封装到子程序中，全局使用会非常麻烦  

可以通过提取用户需求的最小子集，接下来以微小的步伐进行填充，隔离附加的功能。


#### 保持松散耦合
需要考虑的标准有:  

1. 规模，少即是多
2. 可见性，不要隐藏，真情吐露就行
3. 灵活性，考虑是传参还是传对象其实就是一个纠结点  

耦合的种类（1、2不错，3、4复杂）:  

1. 简单数据参数耦合
2. 简单对象耦合（不懂）
3. 对象参数耦合
4. 语义上的耦合，需要知道内部细节（极差）  

注意，类的目的是简化复杂度，如果没有，那么就是它失职

#### 查阅常用设计模式
目的是通过制度化降低复杂度，同时也便于理解协作  
![设计的层次示意图](./img/designpattern.png)  


#### 其它启发式方法
1. 高内聚，子程序在支持一个中心目标的紧密程度
2. 构造分层
3. 严格描述类契约
4. 分配职责
5. 为测试而设计
6. 避免失误
7. 有意识的选择绑定时间
8. 创建中央控制点(查找越小就越安全)
9. 考虑使用蛮力突破（二分法[1946]vs顺序查找）
10. 画一个图，一图胜千言啊
11. 模块化

#### 启发式方法原则
> 理解问题->设计计划->执行计划->回顾  

注意，如果不行就换方法，实在不行就先出去走走，再不行就等到有足够信息的时候再去做。


### 设计实践
1. 迭代，多试试自然就好了，爱迪生就是个例子
2. 分而治之，
3. 自上而下或自下而上的设计方法，并不冲突，但是自上而下貌似更适合程序员
4. 建立实验性原型,是指写出用于回答特定设计问题的、量最少的且能够随时扔掉的代码，如果相信代码会用到是不可能写出最小代码的。
5. 合作设计，指和他人讨论或向他人求助，硬是找不到人时**可以丢箱里个把星期，回过头再来看**。
6. 做多少设计才够（80%设计，20%写文档）  
7. 记录你的设计成果
   - 插入到代码里
   - 记录到wiki
   - 写总结邮件
   - 使用数码相机
   - 保留设计挂图
   - 使用CRC(类、职责、合作者)卡片
   - 在适当的细节层创建UML


### 对流行设计的评论
迭代吧，少年

### 更多资源
主要有以下几类:

1. 软件设计。一般性问题(<<面向对象编程>>)
2. 软件设计理论
3. 设计模式
4. 广义的设计
5. 标准，参考**核对表(软件构造中的设计)**





