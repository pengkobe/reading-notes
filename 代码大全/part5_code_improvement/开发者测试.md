# 开发者测试 22

## 开发者在软件质量中的角色
根据项目大小和复杂度的不同，开发者测试应该占整个项目时间的*8%~25%*左右
测试活动对绝大多数开发人员是一种煎熬:

1. 其与开发活动背道而驰
2. 测试永远不能证明彻底没错误
3. 测试本身不会改善软件质量
4. 测试要求你假设可以在代码中找到错误

### 构建中的测试
尽量在子程序内单独进行调试，要是集成后再去进行调试发现错误的难度会增加许多。


## 开发者测试的推荐方法
需要确保能做到以下几项:

1. 对每一项需求进行测试
2. 对每一项设计关注点进行测试
3. 用基础测试来扩充对对需求和设计中的详细测试用例
4. 使用检查表进行记录

### 测试先行还是后行
作者还是很支持测试先行的，认为能够更早发现缺陷，无论是需求还是代码的问题都能及早发现，从而写出高质量的代码

### 开发者测试局限性
1. 开发者测试趋向于“干净测试”，实际上肮脏测试得扩大25倍
2. 开发者对覆盖率过于乐观估计
3. 会忽略一些更复杂的测试覆盖率类型


## 测试机=技巧锦囊

### 不完整测试
选出那些可能找出错误的测试用例

### 结构化基础测试
作者提供了一种写最少测试用例的计算方法

1. 对于子程序的直路，开始计1
2. 遇到if/while/for/and/or 加1
3. case 加1，没有default再加1


### 数据流测试
重点对已定义-已使用进行探究，虽然工作量有点大，或许能获得基础测试并不能发现的案例

### 等价类划分
一般测试<时，那么等价类是>=。(从规格说明审视还是有一定好处的)

### 猜测错误
  1. 边界值分析
  2. 复合边界值，重点找出隐含的边界值

### 几类坏数据
如员工数位负数

### 几类好数据
注意与旧程序的兼容性

### 采用容易手工检查的测试用例
事实上丑八怪数据并不比容易手工检查的数据容易把错误揪出来


## 典型错误
### 哪些类包含错误
其实错误分布也遵循2/8原则，对容易出现错误的子程序有时候推倒重来未尝不是一件好事

### 错误的分类
大多数错误基本上是由程序员引起的，拼写错误与错误的理解设计都会导致错误的发生，
当然，大多数错误很容易修正，你需要总结经验，避免下次重犯。  
除了程序员，矛盾的需求，不恰当的沟通以及频繁地变动也会引发错误。

### 不完善的构建过程引发错误所占比例
作者的一些结论 

1.  小型项目（代码少于1000行），构建占80%以上
2. 至少占35%
3. 修正成本较为低廉

### 你期望多少错误
一般1000行1~20个错误，大公司一般会有严格的错误控制标准

### 测试本身错误
需要做到以下几项来降低错误

1. 做详细的检查
2. 开发软件时即计划好测试用例
3. 保留测试用例
4. 将单元测试纳入测试框架(如JUNIT)


## 测试支持工具

### 为测试各个类构造脚手架

### Diff工具

### 测试数据生成器
随机的测试数据生成器能够产生意想不到的、不寻常的测试数据组合

### 覆盖率监视器

### 数据记录器/日志记录器

### 符号调试器

### 系统干扰器
有如下功能: 

1. 填充内存
2. 内存抖动
3. 选择性的内存失败
4. 内存访问边界检查

### 错误数据库
将错误归档是个不错的主意。


## 改善测试过程

### 有计划地测试

### 重新测试(回归测试)

### 自动化测试




## 保留测试记录
准确的讲就是对测试发现的问题进行完整描述，记录其
影响范围，修复所花时间，并进行分类与总结，降低下次重犯的几率。


## 附录
核对表:测试用例
 

